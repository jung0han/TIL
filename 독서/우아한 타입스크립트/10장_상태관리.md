
## 10.1 상태 관리

### 1. 상태

> 렌더링 결과에 영향을 주는 정보를 담은 순수 자바스크립트 객체

상태는 시간이 지나면서 변할 수 있는 동적인 데이터이며 값이 변경될 때마다 컴포넌트의 렌더링 결과물에 영향을 준다. 상태는 지역 상태, 전역 상태, 서버 상태로 분류할 수 있다.

#### 지역 상태
컴포넌트 내부에서 사용되는 상태로 useState 훅을 가장 많이 사용하며 useReducer와 같은 훅을 사용하기도 한다.
#### 전역 상태
앱 전체에서 공유하는 상태로 여러개의 컴포넌트가 전역 상태를 사용할 수 있으며 상태가 변경되면 컴포넌트들도 업데이트 된다. Prop drilling 문제를 피하기 위해 지역 상태를 해당 컴포넌트들 사이의 전약 상태로 공유할 수도 있다.
#### 서버 상태
사용자 정보, 글 목록 등 외부 서버에 저장해야 하는 상태들을 의미한다. UI 상태와 결합하여 관리하며 로딩 여부나 에러 상태 등을 포함한다.

### 2. 상태를 잘 관리하기 위한 가이드

상태는 복잡성을 증가시키고 동작을 예측하기 어렵게 만드며 상태가 업데이트 될 때마다 리렌더링이 발생되므로 유지보수 및 성능 관점에서 상태의 개수를 최소화 하는 것이 바람직하다.

#### 시간이 지나도 변하지 않는다면 상태가 아니다

시간이 지나도 변하지 않는 값이라면 객체 참조 동일성을 유지하는 방법을 고려할 수 있다. 컴포넌트가 마운트 될 때만 스토어 객체 인스턴스를 생성하고 컴포넌트가 언마운트 될 때까지 해당 참조가 변하지 않는다면 렌더링 될 때마다 개로운 객체 인스턴스가 생성되므로 매번 다른 객체로 인식되어 불필요한 리렌더링이 자주 발생할 수 있다. 따라서 컴포넌트 라이프사이클 내에서 마운트 될 때 인스턴스가 생성되고 렌더링 될 때마다 동일한 객체 참조가 유지되도록 구현해야 한다.

객체의 참조 동일성을 유지하기 위해 주로 사용되는 방법은 메모이제이션으로 useMemo를 활용하여 컴포넌트가 마운트될 때만 객체 인스턴스를 생성하고 이후 렌더링에서는 이전 인스턴스를 재활용할 수 있다.

다만 useMemo를 통한 메모이제이션은 의미상으로 보장된 것이 아니므로 성능 향상을 위한 용도로만 사용되어야 한다. 따라서 useMemo 없이도 올바르게 동작하도록 코드를 작성하고 나중에 useMemo를 추가하는 것이 적절하다.

```ts
const store = useRef<Stroe>(null);

if (!store.current) {
	store.current = new Store();
}
```

#### 파생된 값은 상태가 아니다

부모에게서 전달 받을 수 있는 props이거나 기존 상태에서 계산될 수 있는 값은 상태가 아니다. SSOT<sup>Single Source Of Truth</sup>는 어떠한 데이터도 단 하나의 출처에서 생성하고 수정해야 한다는 원칙을 의미하는 방법론이며 리액트 앱에서 상태를 정의할 때도 이를 고려해야 한다. 다른 값에서 파생된 값을 상태로 관리하게 되면 기존 출처와는 다른 새로운 출처에서 관리하게 되어 데이터의 정확성과 일관성을 보장하기 어렵다.

부모 컴포넌트로 부터 전달 받은 prop의 값을 initialValue로 사용하여 상태를 관리할 때 컴포넌트가 마운트 된 이후에 전달되는 값이 변경되더라도 동기화되지 않는다. 보통 useEffect를 이용해 동기화 하는 것으로 고려하는데 내부에 있는 상태를 useEffect를 이용해 동기화하면 개발자가 추적하기 어려운 오류가 발생할 수 있으므로 피해야 한다.

일반적으로 리액트에서는 상위 컴포넌트에서 상태를 관리하는 상태 끌어올리기 기법을 사용한다.

파생된 상태가 있을 경우 자바스크립트 변수로 등록할 경우 리렌더링을 줄이고 파생 상태를 잘 관리할 수 있으며 반복된 계산을 막기 위해 useMemo도 활용할 수 있다.

#### useState vs useReducer, 어떤 것을 사용해야 할까

useState 대신 useReducer 사용을 권장하는 경우
- 다수의 하위 필드를 포함하고 있는 복잡한 상태 로직을 다룰 때
- 다음 상태가 이전 상태에 의존적일 때

useReducer는 무엇을 변경할지와 어떻게 변경할지를 분리하여 액션으로 넘기고 reducer 함수 내에서 상태를 업데이트하는 방식을 정의한다.

boolean 상태를 토글하는 액션만 사용하는 경우에도 useReducer를 사용하곤 한다.

### 3. 전역 상태 관리와 상태 관리 라이브러리

> 상태는 사용하는 곳과 최대한 가까워야 하며 사용범위를 제안해야만 한다.

어떠한 상태를 컴포넌트 내부에서만 사용하는게 아니라 다른 컴포넌트와 공유할 수 있는 전역 상태로 사용하는 방법은 리액트 컨텍스트 API를 사용하는 방법과 외부 상태 관리 라이브러리를 사용하는 방법이 있다.

#### 컨텍스트 API

깊은 레벨에 있는 컴포넌트 사이에 데이터를 전달하는 Prop Drilling 같은 문제를 해결하기 위한 도구로 활용된다.

상위 컴포넌트 구현 부에 컨텍스트 프로바이더를 넣어주고 하위 컴포넌트에서 해당 컨텍스트를 구독하여 데이터를 읽어오는 방식으로 사용할 수 있다.

다만 컨텍스트 프로바이더의 props로 주입된 값이나 참조가 변경될 때마다 해당 컨텍스트를 구독하고 있는 모든 컴포넌트가 리렌더링되므로 성능이 중요한 애플리케이션에서 권장되지 않는다.

## 10.2 상태 관리 라이브러리

#### MobX
상태 변경 로직을 단순하게 작성 할 수 있지만 데이터가 언제, 어떻게 변하는지 추적하기 어렵다.
#### Redux
오랜 기간 사용되며 다양한 요구사항에 대해 검증되었으며 상태 변경 추적이 용이하다. 하지만 많은 보일러플레이트가 필요하고 사용 난이도가 높다.
#### Recoil
보일러플레이트가 적고 난이도가 낮아 배우기 쉽지만 라이브러리가 아직 충분한 검증이 이루어지지 않았다.
#### Zustand
특정 라이브러리에 종속되지 않고 편리하게 사용할 수 있다.