## 7.1 API 요청

### 1. fetch로 API 요청하기

fetch로 API를 요청할 때 동일한 코드를 복붙하여 사용하면 백앤드의 기능 변경으로 API URL을 변경해야 할 때, timeout 설정이나 header 변경 등 추가 요구를 대응하기 위해 계속해서 코드를 수정해야 하는 번거로움이 있다.

### 2. 서비스 레이어로 분리하기

이를 방지하기 위해 비동기 호출 코드를 서비스 레이어에서 처리 할 수 있다.

fetch 함수를 호출하는 부분을 서비스 레이어로 이동 시키고 컴포넌트는 서비스 레이어의 비동기 함수를 호출하고 결과를 받아 렌더링 한다.

다만, fetch 함수를 분리하는 것만으로는 API 요청 정책 변경에 대응하기 어렵다.

### 3. Axios 활용하기

Axios를 사용하면 많은 기능을 별도로 개발하지 않고 활용 할 수 있다.

각 서버가 담당하는 부분이 달라 API Entry가 2개 이상일 때는 각각의 apiRequester를 사용하면 된다.
axios.create를 이용하여 baseURL을 각각 정의하여 사용 할 수 있다.

### 4. Axios 인터셉터 사용하기

각각의 requester별로 다른 헤더를 설정해야 한다면 인터셉터 기능을 사용하여 비동기 호출 내용을 추가 할 수 있다.

설정 옵션을 정의하는 setRequestDefaultHeader 함수를 만들고 apiRequester.interceptors.request.use를 이용해 적용한다.

apiRequester.interceptors.response.use를 이용하여 response를 받아 httpError를 처리하는 핸들러를 추가 할 수 있다.

APIBuilder 같은 클래스 형태로 구성할 수도 있다. API 클래스로 호출 부분을 구성하고 API를 호출하기 위한 래퍼를 빌더 패턴으로 만든다. 이 경우 보일러플레이트 코드가 많다는 단점은 있지만 옵션이 다양한 경우 인터셉터를 설정값에 따라 적용하고 필요 없는 인터넷터를 선택적으로 사용할 수 있다.

### 5. API 응답 타입 지정하기

서버에서 오는 응답의 타입을 지정할 때 UPDATE나 CREATE와 같이 응답이 없을 수 있는 API를 함께 처리하기 위해 apiRequester가 모르게 관리해야 한다.

로그를 위해 단순히 받아서 넘겨주는 값의 타입은 unknown을 유지해도 괜찮지만 이미 사용하고 있는 값이라면 프론트 로직에서 써야 하는 값에 대해서만 타입을 선언한 후 사용하는 것이 좋다.

### 6. 뷰 모델 사용하기

API 응답은 변할 수 있으므로 뷰 모델을 사용해서 API 변경에 따른 범위를 한정해야 한다.

흔히 좋은 컴포넌트는 변경될 이유가 하나뿐인 컴포넌트라고 한다. API 응답의 인자를 정확한 개념을 나타내기 위해 수정한다면 해당 컴포넌트도 수정해야 하며 API를 사용하는 기존 컴포넌트도 수정되어야 한다.

이를 해결하기 위해 뷰 모델을 도입할 수 있다.

JobList라는 객체를 만들고 응답의 데이터를 해당 객체에 넣어서 리턴하면 API 응답에 없는 도메인 개념을 넣을 때 쉽게 새로운 필드를 추가 할 수 있다.

다만 추상화 레이어 추가는 코드를 복잡하게 만들고 관리하고 개발하는데도 비용이든다.

### 7. Superstruct를 사용해 런타임에서 응답 타입 검증하기

라이브러리를 이용해 런타임 응답 타입 검증을 할 수 있다. assert, is, validate라는 모듈을 이용해 데이터의 유효성을 검사 할 수 있다.

- assert는 유효하지 않을 경우 에러를 던진다.
- is는 유효성 검사 결과에 따라 true 또는 false를 반환한다.
- validate는 `[error, data]` 형식의 튜플을 반환한다.

### 8. 실제 API 응답 시의 Superstruct 활용 사례

타입스크립트에서 작성한 코드는 명시한 타입대로 응답이 올 거라고 기대하지만 실제 서버 응답은 다를 수 있다. 

타입스크립트는 컴파일 타임에 타입을 검증하므로 실제 서버 응답의 형식과 명시한 타입이 일치하는지를 확인 할 수 없다.

## 7.2 API 상태 관리하기

### 1. 상태 관리 라이브러리에서 호출하기

상태 관리 라이브러리의 비동기 함수들은 서비스 코드를 이용해 비동기 상태를 변화시킬 수 있는 함수를 제공한다. Redux의 경우 전역 상태를 위해 만들어진 라이브러리로 보일러플레이트 코드가 많아져 관리하기 어렵다.

MobX의 경우 비동기 콜백 함수를 분리하여 액션으로 만들거나 runInAction과 같은 메서드를 사용해서 상태 변경을 처리할 수있다.

모든 상태 관리 라이브러리에서 액션이 추가 될 때마다 관련된 스토어나 상태가 계속 늘어나며 전역 상태 관리자가 모든 비동기 상태에 접근하고 변경할 수 있게 되므로 쓸데없는 비동기 통신이 발생하거나 의도치 않은 상태 변경이 발생할 수 있다.

### 2. 훅으로 호출하기

훅은 캐시를 사용하여 비동기 함수를 호출하고 의도치 않은 상태 변경을 방지하는데 도움이 된다. react-query에서는 onSuccess 옵션의 validateQueries를 사용하여 특정 키의 API를 유효하지 않은 상태로 설정할 수 있다.

## 7.3 API 에러 핸들링

### 1. 타입 가드 활용하기

`Axios` 라이브러리에서는 에러에 대해 `isAxiosError`라는 타입 가드를 제공한다. `AxiosError<ErrorResponse>` 로 명시적으로 작성 할 수 있다.

### 2. 에러 서브클래싱하기

다양한 에러를 명시적으로 표현하기 위해 서브클레싱을 활용할 수 있다. 

에러 객체를 상속한 서브 클래스를 정의하고 errorHandler에서 조건에 따라 적절한 객체를 전달한다. 그리고 요청코드에서 isnstanceof로 타입 가드문을 작성하여 에러 핸들링을 할 수 있다.

### 3. 인터셉터를 활용한 에러 처리

interceptors.response.use에 httpErrorHandler를 추가하여 에러 처리를 할 수 있다.

### 4. 에러 바운더리를 활용한 에러 처리

에러 바운더리를 이용하면 리액트 컴포넌트 트리 하위에 있는 컴포넌트에서 발생한 에러를 캐치하고 해당 에러를 가장 가까운 부모 에러 바운더리에서 처리하게 할 수 있다. 이는 에러가 발생한 컴포넌트 대신에 에러 처리를 하거나 예상치 못한 에러를 공통 처리할 때 사용할 수 있다.

### 5. 상태 관리 라이브러리에서의 에러 처리

Redux에서의 에러 처리는 에러 상태를 관리하지 않고 바로 처리할 수 있다면 바로 처리하고 그렇지 않으면 reject으로 넘겨준다. 이후 액션을 정리하면서 setApiCallError를 사용하여 에러를 상태로 처리한다.

저장된 에러는 컴포넌트에서 사용할 수 있으며 주로 스토어에서 에러 핸들링을 한다.

### 6. react-query를 활용한 에러 처리

isError가 true일 경우 메시지를 출력하도록 한다.

### 7. 그 밖의 에러 처리

성공 응답에 대한 에러 처리가 필요할 수 있다. 이 경우 status를 비교하여 성공이 아닐 경우 커스텀 에러를 처리할 수 있다. 커스텀 에러를 사용하는 요청을 일괄적으로 에러로 처리하고 싶다면 axios의 인터셉터에 코드 비교 로직을 추가 할 수 있다.

## 7.4 API 모킹

API가 완성되기 전에 개발을 진행해야 한다면 모킹이라는 방법으로 가짜 모듈을 활용할 수 있다.

### 1. JSON 파일 불러오기

간단한 조회만 필요한 경우 자바스크립트 파일 안에 JSON 형식의 정보를 저장하고 export할 수 있다. 이후 GET 요청에 파일 경로를 삽입하면 원하는 값을 받을 수 있다. 다만 실제 API URL로 요청하는 것이 아니므로 추후 요청 경로를 바꿔야 한다.

### 2. NextApiHandler 활용하기

응답하고자 하는 값을 정의하고 핸들러 안에서 요청에 대한 응답을 정의한다. 이 경우 중간과정에 응답처리 로직을 추가 할 수 있다.

### 3. API 요청 핸들러에 분기 추가하기

API 요청을 훅 또는 별도 함수로 선언한 다음 조건에 따라 목업 함수를 내보내거나 실제 요청 함수를 내보낼 수 있다. 이 경우 개발이 완료된 이후에도 유지보수할 때 목업 함수를 사용할 수 있다.

### 4. axios-mock-adapter로 모킹하기

서비스 함수에 분기문을 추가하지 않기 위해 라이브러리를 사용할 수 있다. 단순히 응답 바디만 모킹하는 것이 아니라 상태 코드, 응답 지연 시간 등을 추가로 설정할 수도 있다. GET 요청 뿐만 아니라 다른 메서드에 대한 목업을 작성할 수도 있고 임의로 에러를 발생시킬 수도 있다.

### 5. 목업 사용 여부 제어하기

플래그를 사용하여 목업으로 개발할 때를 구분할 수 있다. 스크립트 실행 시 구분 짓기 위해 package.json에 관련 스크립트를 추가 할 수 있다.