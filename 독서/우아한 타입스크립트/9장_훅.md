## 9.1 리액트 훅

리액트 훅이 추가 되기 이전에는 클래스 컴포넌트에서만 상태를 가질 수 있었고 componentDidMount, componeneDidUpdate와 같이 하나의 생명주기 함수에서만 상태 업데이트에 따른 로직을 실행 할 수 있었다.

이 경우 프로젝트 규모가 커지면서 상태를 스토어에 연결하거나 비슷한 로직을 가진 상태 업데이트, 사이드 이펙트 처리가 불편해졌다.

그리고 모든 상태를 하나의 함수 내에서 처리하므로 관심사가 뒤섞이고 테스트나 디버깅이 어려워졌다.

리액트 훅이 도입되면서 함수 컴포넌트에서도 컴포넌트의 생명주기에 맞춰 로직을 실행 할 수 있게 되었고 이에 따라 비즈니스 로직을 재사용하거나 코드를 분할하여 테스트 하는 것이 용이해졌다.

### 1. useState

useState는 튜플을 반환하며 첫 번째 요소는 제네릭으로 지정한 S 타입이고 두 번째 요소는 상태를 업데이트 할 수 있는 Dispatch 타입의 함수이다. Dispatch 함수의 제네릭으로 지정한 SetStateAction에는 상태 타입 S 또는 (prevState: S) => S가 들어갈 수 있다.

타입스크립트를 활용하면 새로운 값을 대입하거나 추가할 때 잘못된 속성이 포함된 객체가 추가될 경우 컴파일 타임에 타입 에러를 확인 할 수 있다.

### 2. 의존성 배열을 사용하는 훅

useEffect의 첫 번째 인자인 EffectCallback은 Destructor를 반환하거나 아무것도 반환하지 않는 함수로 경쟁 상태를 일으킬 수 있으므로 비동기 함수는 들어갈 수 없다.

두 번째 인자인 deps는 옵셔널하게 제공되며 deps 배열의 원소가 변경되면 effect가 실행된다. 다만 deps에 객체나 배열은 얕은 비교로 판단하므로 실제 사용하는 값을 사용해야 한다.

Destructor는 deps가 비어 있을 때는 컴포넌트가 마운트 해제될 때에만 실행되고 deps 배열이 존재하면 배열의 값이 변경될 때마다 실행된다.

useLayoutEffect는 레이아웃 배치와 화면 렌더링이 모두 완료된 후에 실행된다.

### 3. useRef

리액트 애플리케이션에서 DOM을 직접 선택해야 하는 경우 useRef를 사용한다. useRef는 세 종류의 타입 정의를 가지고 있으며 useRef에 넣어주는 인자 타입에 따라 반환되는 타입이 달라진다.

MutablerefObject의 current는 값을 변경할 수 있어 ref.current의 값이 바뀌는 사이드 이펙트가 발생할 수 있다. RefObject의 current는 readonly로 값을 변경할 수 없다.

#### 자식 컴포넌트에 ref 전달하기

기본 HTML 요소가 아닌 리액트 컴포넌트에 ref를 전달 할 수도 있다. props로 넘겨주면 오류가 발생되며 forwardRef를 사용해야 한다.

forwardRef의 두 번째 인자에 ref를 넣어 자식 컴포넌트로 ref를 전달 할 수 있으며 forwardRef에 인자로 넘겨주는 콜백 함수인 ForwardRefRenderFunction은 2개의 타입 매개변수 T와 P를 받는다. P는 일반적인 리액트 컴포넌트에서 자식 컴포넌트로 넘겨주는 props의 타입, T는 ref로 전달하려는 요소의 타입을 나타낸다.

ref의 타입은 `ForwardedRef<T>`이며 해당 타입은 RefObject보다 넓은 범위의 타입을 가진 MutableRefObject가 들어올 수 있다.

#### useImperativeHandle

useImperativeHandle은 ForwardRefRenderFunction과 함께 쓸 수 있는 훅으로 이를 이용해 부모 컴포넌트에서 ref를 통해 자식 컴포넌트에 정의한 메서드를 호출 할 수 있다.

#### useRef의 여러가지 특성

useRef는 자식 컴포넌트를 저장하는 변수로 활용할 뿐 아니라 다른 방식으로도 유용하게 활용할 수 있다.
- useRef로 관리되는 변수는 값이 바뀌어도 컴포넌트의 리렌더링이 발생되지 않으므로 이를 이용해 불필요한 리랜더링을 피할 수 있다.
- 리액트 컴포넌트의 상태는 상태 변경 함수를 호출하고 렌더링 된 이후에 업데이트된 상태를 조회 할 수 있는데 useRef로 관리되는 변수는 값을 설정한 후 즉시 조회 할 수 있다.

> 반복문으로 함수 컴포넌트가 종료되거나, 조건문 또는 변수에 따라 반복문 등으로 훅의 호출여부가 결정되지 않아야 useState나 useEffect가 여러번 호출되더라도 훅의 상태를 올바르게 유지할 수 있으므로 훅은 항상 최상위 레벨에서 호출해야 한다.

> 훅은 함수 컴포넌트나 커스텀 훅 등의 리액트 컴포넌트 내에서만 호출되어야 한다.

## 9.2 커스텀 훅

### 1. 나만의 훅 만들기

사용자 정의 훅을 생성하여 컴포넌트 로직을 함수로 뽑아내 재사용할 수 있으며 커스텀 훅의 이름은 반드시 use로 시작해야 한다.