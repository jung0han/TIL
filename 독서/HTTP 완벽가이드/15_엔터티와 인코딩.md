HTTP는 매일 수십억개의 미디어 객체를 전달하며 메시지가 올바르게 수송, 식별, 추출, 처리되는 것을 보장한다.

- 객체가 올바르게 식별되어 브라우저나 다른 클라이언트는 컨텐츠를 바르게 처리할 수 있다. (Content-Type/Content-Language)
- 객체의 압축을 재대로 풀 수 있다. (Content-Lengh/Content-Encoding)
- 항상 최신 객체를 가져온다. (엔터티 검사/캐시 만료 제어)
- 사용자의 요구를 만족한다. (Accept 헤더)
- 네트워크 사이를 빠르고 효율적으로 이동한다. (범위 요청/델타 인코딩/데이터 압축)
- 데이터는 조작되지 않고 온전하게 전달된다. (전송 인코딩 헤더/Conetne-MD5 체크섬)

## 15.1 메시지는 컨테이너, 엔터티는 화물

아래 엔터티 헤더는 18자의 텍스트 문서를 의미한다.

```HTTP
HTTP/1.0 200 OK
Server: Netscape-Enterprise/3.6
Date: Sun, 17 Sep 2000 00:01:05 GMT
Content-type: text/plain
Content-length:  18

Hi! I'm a message!
```

주요 엔터티 헤더 필드는 아래와 같다.

Content-Type
- 엔터티에 의해 전달된 객제의 종류

Content-Length
- 전달되는 메시지의 길이나 크기

Content-Language
- 전달되는 객체와 가장 잘 대응되는 자연어

Content-Encoding
- 객체 데이터에 대해 정해진 변형

Content-Location
- 요청 시점을 기준으로, 객체의 또 다른 위치

Content-Range
- 엔터티가 부분 엔터티일 경우 전체에서 어느부분에 해당되는지 정의

Content-MD5
- 엔터티 본문의 콘텐츠에 대한 체크섬

Last-Modified
- 서버에서 이 콘텐츠가 생성되거나 수정된 날

Expires
- 엔터티 데이터가 만료된 것으로 간주되는 날짜와 시간

Allow
- 어떤 메서드가 허용되는지 정의

ETag
- 인스턴스에 대해 고유한 검사기로 엔터티와 관련한 동작을 하기 위해 필요한 헤더

Cache-Control
- 캐시에 관한 지시자

### 15.1.1 엔터티 본문

엔터티 본문은 가공되지 않은 데이터만을 가지고 있으며 다른 정보는 모두 헤더에 있다. 엔터티 헤더에 데이터의 의미에 대해 설명되어 있으며 Content-Type은 테이터를 어떻게 해석해야 하는지, Content-Encoding은 데이터가 압축되었거나 추가적인 인코딩이 되었는지 알려준다.

엔터티 본문은 데이터의 종류나 상태와 관계 없이 빈 CRLF줄 바로 다음부터 시작한다.

## 15.2 Content-Length

이 헤더는 본문의 크기를 바이트 단위로 나타내며 압축된 텍스트 파일이라면 압축된 후의 크기를 표시한다.

청크 인코딩으로 전송하지 않는 이상 필수로 있어야 하는 헤더이고 서버 충돌로 인해 메시지가 잘렸는지 감지하거나 지속 커넥션을 공유하는 메시지를 분할 할 때 필요하다.

### 15.2.1 잘림 검출

이전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인식했는데 Content-Length가 없으면 커넥션이 정상적으로 종료된 것인지 구분 할 수 없다.

캐싱 프락시 서버에서 특히 취약하며 캐시가 잘린 메시지를 수신하고 잘림을 인식하지 못했다면 결함 있는 데이터를 계속 제공하게 된다. 잘린 메시지 캐싱을 방지하기 위해 프락시 서버는 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보통 캐싱하지 않는다.

### 15.2.2 잘못된 Content-Length

Content-Length가 없는 것 보다 잘못 된 것이 더 큰 문제를 일으킨다. 초창기 클라이언트와 서버들 일부는 Content-Length 계산과 관련한 버그가 있어 몇몇 클라이언트, 서버, 프락시 들은 오동작을 했는지 탐지하고 교정을 시도한다. 공식적으로 HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 이를 인지하면 사용자에게 알려준다.

### 15.2.3 Content-Length와 지속 커넥션

응답이 지속 커넥션을 통해서 왔다면 다른 HTTP 응답이 이어질 것으로 예상되고 Content-Length 헤더는 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려준다.

커넥션이 지속되기 때문에 커넥션이 닫힌 위치로 끝을 인식 할 수 없다.

청크 인코딩을 사용하는 경우도 있다. 청크 인코딩은 데이터를 특정한 크기를 갖는 청크로 쪼개서 보내는데 서버가 헤더가 생성되는 시점에서 엔터티 전케의 크기를 알 수 없더라도 청크 인코딩을 이용해 조각들로 전송 할 수 있다.

### 15.2.4 콘텐츠 인코딩

HTTP는 보안을 강화하거나 압축을 위해 엔터티 본문을 인코딩 할 수 있게 해 준다. 본문의 콘텐츠가 인코딩 됐다면 Content-Length 헤더는 인코딩 된 길이를 바이트단위로 정의한다.

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

엔터티 본문의 길이와 끝나는 위치를 판별하는 규칙으로 순서대로 적용된다.

1. 본문을 갖는 것을 허용하지 않는 메시지에서는 Content-Length 헤더가 무시된다. 이 경우 해당 헤더는 실제 본문 길이를 표시하지 않는다. HEAD 응답이 대표적인 예로 본문을 제외하고 헤더만 전달된다.
2. 메시지가 Transfer-Encoding 헤더를 가지고 있다면 커넥션이 닫히지 않는 이상 '0바이트 청크'라는 특별한 패턴으로 끝나야 한다.
3. Transfer-Encoding 헤더를 Content-Length 헤더를 가지고 있다면 엔터티 본문의 표현, 전송 방식이 다르기 때문에 Content-Length 헤더를 무시해야 한다. 
4. 메시지가 'multipart/byteranges' 미디어 타입을 사용하고 길이가 별도로 정의 되지 않았다면 스스로 크기를 정의한다. 다만 수신자가 이를 해석할 수 있을 때 보내야 한다.(2014년 규칙 삭제)
5. 위의 규칙에 해당되지 않으면 엔터티는 커넥션이 닫힐 때 끝난다. 서버만이 커넥션을 닫을 수 있다.
6. HTTP/1.1 명세는 본문은 있지만 Content-Length 헤더가 없는 경우 400 Bad Request 응답을 보내고 유효한 Content-Length를 요청 할 때 411 Length Required 응답을 보내도록 권장된다.

## 15.3 엔터티 요약

HTTP는 일반적으로 TCP/IP 같이 신뢰성이 있는 전송 프로토콜을 사용하지만 불완전한 트랜스코딩 프락시나 중개자 프락시의 버그와 같은 여러 이유로 메시지의 일부분이 변형되는 경우가 발생된다.

엔터티 본문의 변형을 감지하기 위해 송신자는 데이터에 대한 체크섬을 생성할 수 있고 수신자는 그 체크섬으로 기본적인 검사를 할 수 있다. 다만 요약 헤더를 교체하는 악의적인 공격에는 대처 할 수 없다.

Content-MD5 헤더는 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보낼 때 사용되고 응답을 처음 만든 서버에서만 해당 헤더를 계산해 전송하고 중간의 프락시와 캐시는 종단간 무결성 훼손시키지 않기 위해 헤더를 수정하지 않는다.

클라이언트에서 무결성을 검증하려면 전송 인코딩을 디코딩 한 뒤 디코딩 된 본문에 대해 MD5를 계산해야 한다. 만약 gzip 알고리즘으로 압축해서 청크 인코딩으로 보냈다면 MD5 알고리즘은 압축된 본문 전체에 적용된다.

문서의 위치를 빠르게 알아내고 콘텐츠의 중복 저장을 방지하기 위한 해시 테이블의 키로 이용될 수 있지만 Content-MD5 헤더는 그리 자주 전송되지 않는다.

HTTP의 확장들은 Want-Digest 헤더를 제안했으며 품질값을 이용해 요약 알고리즘을 제안하고 선호도를 지정할 수 있다.

## 15.4 미디어 타입과 차셋

Content-Type 헤더는 엔터티 본문의 MIME 타입을 기술하는데 이는 전달되는 데이터의 형식의 표준화된 이름이다.

MIME 타입은 주 미디어 타입으로 시작해 더 구체적으로 서술하는 부 타입으로 구성된다. 원본 엔터티 본문의 미디어타입 명시는 콘텐츠 인코딩을 거친 경우에도 엔터티 본문 유형을 파악하기 위해 중요하다.

### 15.4.1 텍스트 매체를 위한 문자 인코딩

엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 `charset` 매개변수가 있다.

### 15.4.2 멀티파트 미디어 타입

멀티파트 이메일 메시지는 붙어있는 여러개의 메시지를 포함해 하나의 복합 메시지로 보내진다. 각 구성요소는 헤더를 포함하고 문자열 하나로 경계가 식별된다.

HTTP는 멀티파트 본문을 지원하지만 폼을 채워서 제출할 때, 범위 응답을 할 때에만 허용된다.

### 15.4.3 멀티파트 폼 제출

HTTP 폼을 채워서 제출하면 여러 객체가 하나의 파트로 보내지며 Content-Type: multipart/form-data나 Content-Type: multipart/mixed 헤더에 boundary를 함께 보내고 이는 각각을 구분하기 위한 구분자로 쓰인다.

### 15.4.4 멀티파트 범위 응답

범위 요청에 대한 HTTP 응답도 멀티파트가 될 수 있고 이 경우 Content-Type: multipart/byteranges 헤더와 멀티파트 본문이 함께 온다.

![멀티파트 범위 응답 예시](attachments/Pasted%20image%2020231111105517.png)

## 15.5 콘텐츠 인코딩

전송시간을 줄이거나 콘텐츠를 암호화 하기 위해 콘텐츠를 인코딩 해서 보낼 수 있다.

### 15.5.1 콘텐츠 인코딩 과정

인코딩 과정은 아래와 같다.

1. 웹서버가 Content-Type과 Content-Length 헤더를 포함한 원본 메시지를 생성한다.
2. 콘텐츠 인코딩 서버가 메시지를 인코딩하고 Content-Length를 업데이트하고 Content-Encoding 헤더를 메시지에 추가한다.
3. 클라이언트는 메시지를 받아서 디코딩한다.

### 15.5.2 콘텐츠 인코딩 유형

인코딩 유형은 IANA를 통해 표준화되고 gzip, compress, deflate 인코딩은 무손실 압축 알고리즘이고 gzip을 주로 사용한다.

### 15.5.3 Accept-Encoding 헤더

클라이언트는 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더로 전달한다. 만약 이 헤더가 없다면 어떤 인코딩이든 지원하는 것으로 간주한다.

클라이언트는 각 인코딩에 0.0~1.0범위의 Q값을 매개변수로 전달할 수 있다.

```
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity;q=0.5, *;q=0
```
## 15.6 전송 인코딩과 청크 인코딩

텍스트 파일은 보통 gzip으로 인코딩 하지만 jpeg 파일은 잘 압축되지 않으므로 인코딩 하지 않는다.

전송 인코딩은 콘텐츠의 포멧과는 독립적이며 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메시지에 적용 할 수 있다.

### 15.6.1 안전한 전송

표준화 되고 좋은 전송 기반에서 동작하는 HTTP는 전송 인코딩을 아래의 문제를 해결하는데 사용하고 있다.

#### 알 수 없는 크기
콘텐츠의 사이즈를 알기 전에 데이터 전송을 시작하려고 하는 경우 몇몇 서버는 특별한 종결 꼬리말을 포함시켜 데이터를 보내려 한다.

#### 보안
네트워크로 콘텐츠를 보내기 전에 전송 인코딩으로 메시지를 뒤섞어버릴 수 있지만 SSL과 같은 보안 방식이 있으므로 잘 사용되지 않는다.

### 15.6.2 Transfer-Encoding 헤더

#### Transfer-Encoding
전송을 위해 적용한 인코딩의 종류를 알려준다.

#### TE
어떤 확장된 전송 인코딩을 사용할 수 있는지 알려준다. 아래는 chunk-encoded 메시지와 메시지의 끝의 트레일러를 받을 수 있음을 알리기 위한 요청이다.

```http
GET /new_products.html HTTP/1.1
Host: www.joes-hardware.com
User-Agent: Mozilla/4.61 [en] (WinNT; I)
TE: trailers, chunked
...
```

메시지가 청크 인코딩으로 전송 인코딩된 것을 알려주기 위해 Transfer-Encoding 헤더를 포함한다.

```http
HTTP/1.1 200 0K
Transfer-Encoding: chunked
Server: Apache/3.0
...
```

이 헤더 뒤에 미시지의 구조가 변한다.

모든 전송 인코딩 값은 대소문자가 구별되며 최신 HTTP 명세에서는 청크 인코딩만 정의되었으며 TE 헤더는 Q 값을 가질 수 있는데 0.0을 갖는것은 금지한다.

미래의 HTTP 확장은 전송 인코딩 추가에 대한 요구를 수용할 수도 있고 그 경우 청크 전송 인코딩은 확장 전송 인코딩의 최상위에서 적용돼야 한다. 그래야 청크 인코딩 외 다른 전송 인코딩을 지원하지 않는 어플에서도 터널링의 동작을 보장한다.
### 15.6.3 청크 인코딩

메시지를 일정 크기의 청크로 쪼개서 순차적으로 전송하는 방식으로 메시지를 보내기 전에 전체 크기를 알 필요가 없다. 본문이 동적으로 생성되며 서버는 일부를 버퍼에 담은 뒤 본문 전체를 보낼 때 까지 청크를 크기와 함께 보내는 작업을 반복한다.

청크 인코딩은 전송 인코딩의 형태로 본문이 아닌 메시지의 속성이다. 앞의 멀티파트 인코딩은 본문의 속성으로 청크 인코딩과는 분리된다.

#### 청크 인코딩된 메시지의 트레일러

다음 조건 중 하나 이상을 만족하면 청크 메시지에 트레일러를 추가 할 수 있다.

- 클라이언트의 TE 헤더가 트레일러를 받을 수 있다고 명시된 경우
- 트레일러가 응답을 만든 서버의 의해 추가되었고 트러일레의 컨텐츠가 선택적인 메타에디터로 클라이너트가 무시해도 되는 경우

트레일러에는 메시지 시작 시점에서 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있다. Transfer-Encoding, Trailer, Content-Length를 제외한 모든 헤더를 트레일러로 보낼 수 있다.

### 15.6.4 콘텐츠와 전송 인코딩의 조합

컨텐츠 인코딩과 전송 인코딩을 동시에 사용하며, 예를 들어 컨텐츠 인코딩으로 HTML 파일을 압축하고 청크 데이터를 전송 인코딩을 사용해 보낼 수 있다.

### 15.6.5 전송 인코딩 규칙

전송 인코딩이 메시지 본문에 적용될 때 아래 규칙이 반드시 적용되어야 한다.

- 메시지가 커넥션 종료로 끝나는 경우를 제외하고 전송 인코딩의 집합은 반드시 `chunked`를 포함해야 한다.
- 청크 전송 인코딩이 사용되면 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
- 청크 전송 인코딩은 메시지 본문에 한 번 이상 적용되어야 한다.

전송 인코딩은 비교적 새로운 기능으로 지원되지 않는 서버에 전송 인코딩된 메시지를 보내지 않도록 주의해야 한다. 만약 이해 할 수 없는 전송 인코딩 된 메시지를 받았다면 501 Unimplemented 상태 코드로 등답해야 한다.

## 15.7 시간에 따라 바뀌는 인스턴스

웹 객체는 정적이지 않으며 같은 리소스를 요청해도 시간의 흐름에 따라 다른 인스턴스를 받게 된다.

HTTP 프로토콜은 특정한 종류의 요청이나 응답을 다루는 방법을 정의하는데 이를 인스턴스 조작이라고 한다. 대표적으로 범위 요청과 델타 인코딩이 있으며 둘 모두 클라이언트가 가지고 있는 사본이 서버가 갖고 있는 것과 같은지 판단하고 상황에 따라 새 인스턴스를 요청하게 한다.

## 15.8 검사기와 신선도

문서가 클라이언트에서 만료되면 클라이언트는 서버에게 최신 사본을 요청해야 한다. 서버에서도 문서가 변경되지 않았다면 다시 받지 않고 캐시된 사본을 사용 할 수 있다.

조건부 요청이라고 불리는 이 방식은 클라이언트가 서버에게 자신이 갖고 있는 버전을 알려주고 검사기를 이용해 사본 버전이 유효하지 않을 때만 사본을 보내달라고 요청하는 방식이다.

### 15.8.1 신선도

Expires나 Cache-Control 헤더를 통해 컨텐츠의 신선도 정보를 제공 할 수 있다. Expires 헤더를 올바르게 사용하려면 시계를 동기화 해야 하는데 네트워크 시간 프로토콜 같은 시계 동기화 프로토콜을 사용하지 않았을 가능성이 양쪽 모두에게 있으므로 상대시간으로 만료를 정의하는 메커니즘이 더 유용하다. Cache-Control 헤더는 문서의 최대 수명을 문서가 서버를 떠난 후로부터 총 시간을 정하므로 시계 동기화에 의존하지 않는다.

Cache-Contorl 헤더는 서버와 클라이언트 양쪽에서 더 많은 지시자들과 함께 수명이나 유효기간뿐 아니라 선도를 서술하기 위해 사용된다.

![Cache-Control 헤더 지시자](attachments/Pasted%20image%2020231111122528.png)
![](attachments/Pasted%20image%2020231111122558.png)
### 15.8.2 조건부 요청과 검사기

캐시에게 요청이 있을 때 가지고 있는 사본이 신선하지 않다면 가지고 있는 문서를 새로 받아야 한다. 캐시는 원 서버에서 다시 사본을 가지고 올 수 있지만 대부분의 경우 내용은 동일하므로 이 경우 대역폭 낭비와 불필요한 부하를 주지 않기 위해 조건부 요청을 할 수 있다.

조건부 요청은 특정 조건이 참일때만 수행된다. 아래의 경우 2002년 6월 29일 이후 변경된 경우에 한해 파일을 보내달라고 할 수 있다.

```http
GET /announce.html HTTP/1.0
If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMT
```

If-None-Match 조건부 헤더는 문서의 ETag 값을 평가해 버전을 확인하고 버전이 다를 경우 요청을 할 수 있다.

![조건부 요청 유형](attachments/Pasted%20image%2020231111123219.png)

HTTP는 검사기를 약한 검사기와 같한검사기로 분류하며 약한검사기는 리소스의 인스턴스를 고유하게 식별하지 못하는 경우도 있다. 강한 검사기는 언제나 고유하게 식별한다. 예를 들어 바이트 단위 크기 검사기는 약한 검사기이고 암호 체크섬은 강한 검사기이다.

최종 변경 시간은 약한 검사기로 간주되는데 정확도가 최대 1초이기 때문이다. ETag는 강한검사기로 서버에서 변경이 발생 할 때 마다 새로운 값을 넣어주기 때문이다.

서버에서는 캐시된 문서에 대해 재검사로 인한 대량 전송을 유발하지 않고 일부만 약간 수정하기 위해 태그 앖에 `W/`를 붙여 약한 엔터티 태그임을 명시 할 수 있다.

아래 요청이 올 경우 컨텐츠가 문서번호 4.0 이후로 의미있는 변경이 있었을 때만 본문을 반환한다.

```http
GET /announce.html HTTP/1.1
If-None-Match: W/"v4.0"
```
## 15.9 범위 요청

범위 요청을 이용하면 받다가 실패한 엔터티를 범위로 요청아여 다운로드를 중단된 시점에서 재개할 수 있다.

```http
GET /bigfile.html HTTP/1.1
Host: www.joes-hardware.com
Range: bytes=4000-
User-Agent: Mozilla/4.61 [en] (WinNT; I)
...
```

이 경우 처음 4,000바이트 이후 부분을 요청하고 있으며 클라이언트가 처음 4,000바이트만 받고 실패 했을 때 사용할 수 있다. 또한 어떤 문서에 대한 다운로드 시간을 줄이기 위해 동시에 여러 서버에 접속해서 다른 범위를 요청하여 다운 받을 수 있다.

서버는 응답에 Accept-Ranges를 포함해서 범위를 받을 수 있는지를 알려줄 수 있다. 헤더의 값은 측정단위로 보통 바이트이다.

```http
HTTP/1.1 200 0K
Date: Fri, 05 Nov 1999 22:35:15 GMT
Server: Apache/1.2.4
Accept-Ranges: bytes
...
```

범위 요청은 객체의 특정 인스턴스를 클라이언트와 서버 사이에서 교환하는 것으로 인스턴스 조작의 일종임을 주의 해야 한다. 이 범위 요청은 클라이언트와 서버가 같은 버전의 문서를 가지고 있을 때만 의미 있다.
## 15.10 델타 인코딩

인스턴스의 일부가 변경되었을 때 전체를 다시 보내기보다 바뀐 부분만 다시 보내면 대역폭의 손실을 최소화 할 수 있다. 델타 인코딩은 변경된 부분에 대해서만 통신하는 HTTP 프로토콜의 확장으로 일종의 인스턴스 조작이다.

클라이언트는 페이지의 어떤 버전을 가지고 있는지와 델타를 적용하기 위한 어떤 알고리즘을 알고 있는지를 서버에게 알려준다. 서버는 자신이 클라이언트가 갖고 있는 버전을 갖고 있는지 어떻게 델타를 계산할 것인지 체크해야 한다. 그리고 나서 델타를 계산해 클라이언트에게 보내주고 페이지의 최신 버전에 대한 새 식별자를 명시해야 한다.

클라이언트는 자신이 갖고 있는 버전에 대한 식별자를 If-None-Match에 담고 이 헤더에 의해 서버는 최신 버전 전체를 보내게 된다.

대신 클라이언트는 A-IM 헤더를 보내서 델타를 받을 수 있다고 알려줄 수도 있다. 이 헤더 안에 알고 있는 알고리즘을 명시하면 서버는 객체가 아닌 인스턴스 조작을 보내고 있음을 알려주는 226 IM Used 코드와 함께 IM 헤더, 새 ETag 헤더, 기반이 된 문서의 ETag를 지정한 Delta-Base 헤더를 반환한다.

![델타 인코딩 관련 헤더들](attachments/Pasted%20image%2020231111125742.png)
### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

서버의 델타 생성기는 클라이언트의 A-IM 헤더에 지정된 알고리즘으로 이전 문서와 최신 문서간 델타를 계산한다. 델타를 계산하기 위한 알고리즘이 유닉스 diff -e 명령이라면 파일에 대한 줄 단위 비교를 수행하므로 텍스트 파일에서는 문제 없지만 바이너리 파일에서는 실패할 수 있다. vsdiff 알고리즘은 텍스트 파일이 아니라도 동작하며 diff -e보다 더 작은 델타를 생성한다.

![인스턴스 조작의 종류들](attachments/Pasted%20image%2020231111130306.png)

문서는 클라이언트에게 반환되기 전에 압축률을 극대화 하기 위해 gzip 같은 압축 알고리즘을 사용 할 수도 있다.

델타 인코딩은 전송 시간은 줄일 수 있지만 이를 지원하기 위해 서버는 매 순간의 사본을 유지하고 있어야 하므로 구현하기 까다로울 수 있다. 따라서 문서를 제공하는데 걸리는 시간이 줄어드는 대신 과거 사본을 모두 유지하기 위해 디스크 공간을 늘려야 하므로 전송량 감소로 얻은 이득을 무의미하게 만들 수 있다.