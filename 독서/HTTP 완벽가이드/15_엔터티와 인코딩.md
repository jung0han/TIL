HTTP는 매일 수십억개의 미디어 객체를 전달하며 메시지가 올바르게 수송, 식별, 추출, 처리되는 것을 보장한다.

- 객체가 올바르게 식별되어 브라우저나 다른 클라이언트는 컨텐츠를 바르게 처리할 수 있다. (Content-Type/Content-Language)
- 객체의 압축을 재대로 풀 수 있다. (Content-Lengh/Content-Encoding)
- 항상 최신 객체를 가져온다. (엔터티 검사/캐시 만료 제어)
- 사용자의 요구를 만족한다. (Accept 헤더)
- 네트워크 사이를 빠르고 효율적으로 이동한다. (범위 요청/델타 인코딩/데이터 압축)
- 데이터는 조작되지 않고 온전하게 전달된다. (전송 인코딩 헤더/Conetne-MD5 체크섬)

## 15.1 메시지는 컨테이너, 엔터티는 화물

아래 엔터티 헤더는 18자의 텍스트 문서를 의미한다.

```HTTP
HTTP/1.0 200 OK
Server: Netscape-Enterprise/3.6
Date: Sun, 17 Sep 2000 00:01:05 GMT
Content-type: text/plain
Content-length:  18

Hi! I'm a message!
```

주요 엔터티 헤더 필드는 아래와 같다.

Content-Type
- 엔터티에 의해 전달된 객제의 종류

Content-Length
- 전달되는 메시지의 길이나 크기

Content-Language
- 전달되는 객체와 가장 잘 대응되는 자연어

Content-Encoding
- 객체 데이터에 대해 정해진 변형

Content-Location
- 요청 시점을 기준으로, 객체의 또 다른 위치

Content-Range
- 엔터티가 부분 엔터티일 경우 전체에서 어느부분에 해당되는지 정의

Content-MD5
- 엔터티 본문의 콘텐츠에 대한 체크섬

Last-Modified
- 서버에서 이 콘텐츠가 생성되거나 수정된 날

Expires
- 엔터티 데이터가 만료된 것으로 간주되는 날짜와 시간

Allow
- 어떤 메서드가 허용되는지 정의

ETag
- 인스턴스에 대해 고유한 검사기로 엔터티와 관련한 동작을 하기 위해 필요한 헤더

Cache-Control
- 캐시에 관한 지시자

### 15.1.1 엔터티 본문

엔터티 본문은 가공되지 않은 데이터만을 가지고 있으며 다른 정보는 모두 헤더에 있다. 엔터티 헤더에 데이터의 의미에 대해 설명되어 있으며 Content-Type은 테이터를 어떻게 해석해야 하는지, Content-Encoding은 데이터가 압축되었거나 추가적인 인코딩이 되었는지 알려준다.

엔터티 본문은 데이터의 종류나 상태와 관계 없이 빈 CRLF줄 바로 다음부터 시작한다.
## 15.2 Content-Length

이 헤더는 본문의 크기를 바이트 단위로 나타내며 압축된 텍스트 파일이라면 압축된 후의 크기를 표시한다.

청크 인코딩으로 전송하지 않는 이상 필수로 있어야 하는 헤더이고 서버 충돌로 인해 메시지가 잘렸는지 감지하거나 지속 커넥션을 공유하는 메시지를 분할 할 때 필요하다.
### 15.2.1 잘림 검출

이전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인식했는데 Content-Length가 없으면 커넥션이 정상적으로 종료된 것인지 구분 할 수 없다.

캐싱 프락시 서버에서 특히 취약하며 캐시가 잘린 메시지를 수신하고 잘림을 인식하지 못했다면 결함 있는 데이터를 계속 제공하게 된다. 잘린 메시지 캐싱을 방지하기 위해 프락시 서버는 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보통 캐싱하지 않는다.

### 15.2.2 잘못된 Content-Length

Content-Length가 없는 것 보다 잘못 된 것이 더 큰 문제를 일으킨다. 초창기 클라이언트와 서버들 일부는 Content-Length 계산과 관련한 버그가 있어 몇몇 클라이언트, 서버, 프락시 들은 오동작을 했는지 탐지하고 교정을 시도한다. 공식적으로 HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 이를 인지하면 사용자에게 알려준다.

### 15.2.3 Content-Length와 지속 커넥션

응답이 지속 커넥션을 통해서 왔다면 다른 HTTP 응답이 이어질 것으로 예상되고 Content-Length 헤더는 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려준다.

커넥션이 지속되기 때문에 커넥션이 닫힌 위치로 끝을 인식 할 수 없다.

청크 인코딩을 사용하는 경우도 있다. 청크 인코딩은 데이터를 특정한 크기를 갖는 청크로 쪼개서 보내는데 서버가 헤더가 생성되는 시점에서 엔터티 전케의 크기를 알 수 없더라도 청크 인코딩을 이용해 조각들로 전송 할 수 있다.

### 15.2.4 콘텐츠 인코딩

HTTP는 보안을 강화하거나 압축을 위해 엔터티 본문을 인코딩 할 수 있게 해 준다. 본문의 콘텐츠가 인코딩 됐다면 Content-Length 헤더는 인코딩 된 길이를 바이트단위로 정의한다.

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙



## 15.3 엔터티 요약

## 15.4 미디어 타입과 차셋

### 15.4.1 텍스트 매체를 위한 문자 인코딩

### 15.4.2 멀티파트 미디어 타입

### 15.4.3 멀티파트 폼 제출

### 15.4.4 멀티파트 범위 응답

## 15.5 콘텐츠 인코딩

### 15.5.1 콘텐츠 인코딩 과정

### 15.5.2 콘텐츠 인코딩 유형

## 15.6 전송 인코딩과 청크 인코딩

### 15.6.1 안전한 전송

### 15.6.3 청크 인코딩

### 15.6.4 콘텐츠와 전송 인코딩의 조합

### 15.6.5 전송 인코딩 규칙

## 15.7 시간에 따라 바뀌는 인스턴스

## 15.8 검사기와 신선도

### 15.8.1 신선도

### 15.8.2 조건부 요청과 검사기

## 15.9 범위 요청

## 15.10 델타 인코딩