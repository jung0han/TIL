HTTP 메시지는 많은 프로토콜에 의해 통제된다. 리다이렉션 기술은 클라이언트의 메시지를 명시적으로 요청하지 않은 곳으로 보낼 수 있다.

### 20.1 왜 리다이렉트인가?

웹 콘텐츠는 흔히 여러 장소에 배포되며 리다이렉션 기술을 통해 신뢰 할 수 있는 HTTP 트랜잭션의 수행(특정 위치에서 요청이 실패 할 경우 다른 곳을 이용), 지연 최소화(클라이언트가 가까운 리소스에 접근 가능), 네트워크 대역폭 절약(목적지 서버의 분산)이 가능하다.

### 20.2 리다이렉트 할 곳

리다이렉션은 분산된 콘텐츠를 찾는 것과 함께 로드 벨런싱을 다룬다.

서버, 프락시, 캐시, 게이트웨이는 모두 클라이언트 측에서 보면 서버로 볼 수 있으며 많은 리다이렉션 기법이 이들 모두에서 동작하며 일부 특별히 설계된 리다이렉션 기술은 특정 종단에서만 동작한다.

웹 서버는 IP별로 요청을 다루며 복제된 서버들로 요청을 분산한다는 것은 같은 URL에 대해 최적의 웹 서버로 보내는 것을 의미한다.

프락시는 프로토콜별로 요청을 다루며 이웃의 모든 HTTP 트래픽은 프락시 캐시로 들어가는 것이 이상적이다.
### 20.3 리다이렉션 프로토콜의 개요

브라우저 설정, DNS, TCP/IP 라우팅, 그리고 HTTP는 모두 메시지를 리다이렉트 하는 메커니즘을 제공하며 브라우저 설정은 프록시로 향하는 리다이렉트 트래픽에 대해서만 사용할 수 있다.

### 20.4 일반적인 리다이렉션 방법

#### 20.4.1 HTTP 리다이렉션

웹 서버에서 다른 곳에 요청을 보내라는 의미의 리다이렉트 메시지를 응답 할 수 있으며 HTTP 리다이렉션의 장점 중 하나로 리다이렉트를 하는 서버가 클라이언트의 아이피 주소를 알기 때문에 브라우저와 서버간의 거리를 고려하여 리다이렉션 위치를 선정 할 수 있으며 클라이언트마다 각각 다른 서버로 리다이렉트 할 수 있다.

HTTP 리다이렉션은 상태코드 302와 함께 리다이렉트 메시지를 돌려주면 브라우저는 호스트를 변경하여 리다이렉트 URL에 다시 요청을 보낸다.

```
HTTP/1.0 302 Redirect
Server: ...
Location: http://111.111.11.111/hammers.html
```

다만 클라이언트가 페이지에 접근 할 때마다 두번의 왕복이 필요하고 리다이렉트 위치를 결정 할 때 서버에서 많은 연산을 해야 할 수 있다. 그리고 리다이렉션 서버가 고장나면 사이트에 접근이 불가능하다.

#### 20.4.2 DNS 리다이렉션

DNS는 하나의 주소에 여러 아이피 주소가 존재할 수 있으며 어떤 아이피 주소를 먼저 반환 할 것인지 결정하는 단순한 방법부터 복잡한 방법까지 다양한 방법이 있다.
##### DNS 라운드 로빈
가장 흔하고 단순한 리다이렉션 기법으로 서버에 대한 클라이언트의 상대 위치나 서버의 부하를 고려하지 않고 순서대로 아이피 주소들을 부여하는 방식이다.

```shell
$ nslookup www.cnn.com

Name: cnn.com

Addresses: 207.25.71.5, 207.25.71.6, 207.25.71.7, 207.25.71.8
207.25.71.9, 207.25.71.12, 207.25.71.20, 207.25.71.22, 207.25.71.23
207.25.71.24, 207.25.71.25, 207.25.71.26, 207.25.71.27, 207.25.71.28
207.25.71.29, 207.25.71.30, 207.25.71.82, 207.25.71.199, 207.25.71.245
207.25.71.246

Aliases: www.cnn.com

# 현재는 하나의 DNS 주소에서 여러 주소를 출력하지 않는다.
$ nslookup www.cnn.com

Server:		192.168.1.11
Address:	192.168.1.11#53

Non-authoritative answer:
www.cnn.com	canonical name = cnn-tls.map.fastly.net.
Name:	cnn-tls.map.fastly.net
Address: 146.75.51.5
```
##### 다중 주소와 라운드 로빈 주소 순환
대부분의 DNS 클라이언트는 다중 주소 집합의 첫번째 주소를 사용하므로 대부분의 DNS 서버는 룩업이 끝날 때 마다 주소를 순환시키고 이 주소 순환을 DNS 라운드 로빈이라고 부르기도 한다.
##### DNS 캐싱의 효과
DNS 주소 순환은 부하를 순환 시키지만 DNS 룩업의 결과는 어플, 운영체제, 자식 DNS 서버에 의해 저장되어 재 사용될 수 있으므로 완벽하지 않다. 다만 DNS가 단일 클라이언트의 트랜색션을 각각의 서버에 분산 시키지 않더라도 비슷한 요청을 하는 클라이언트의 수가 어느 이상된다면 부하는 상대적으로 잘 분산 될 것이다.
##### 다른 DNS 기반 리다이렉션 알고리즘
###### 부하 균형 알고리즘
가장 로드가 적은 웹 서버를 목록의 가장 위에 놓는다.
###### 근접 라우팅 알고리즘
웹 서버들의 팜이 지리적으로 분산되어 있을 경우 사용자를 근처의 웹 서버로 보낸다.
###### 결함 마스킹 알고리즘
네트워크의 건강 상태를 모니터링하고 장애를 피해서 요청을 라우팅 할 수 있다.

#### 20.4.3 임의 캐스트 어드레싱

지리적으로 흩어진 웹 서버들이 같은 아이피 주소를 갖고 백본 라우터의 최단거리 라우팅을 활용한다. 이 방식은 각 웹서버에게 자신을 인접한 백본 라우터로 향하는 라우터라고 알리고 웹 서버는 라우터 통신 프로토콜을 이용해 인접한 백본 라우터와 통신하게 된다.

백본 라우터가 임의 캐스트 주소를 목적지로 하는 패킷을 받게 되면 그 아이피 주소를 받을 수 있는 가장 가까운 라우터를 찾게되고 가장 가까운 서버는 자신이 그 주소를 위한 라우터라고 알렸기 때문에 백본 라우터는 그 서버에게 패킷을 보내게 된다.

동일 주소를 가지는 장비 중 가장 가까운 장비 하나만 응답하게 되며 트래픽 분산, 네트워크 이중화, DDoS 피해 최소화, 응답 시간 단축 효과를 얻을 수 있다.

#### 20.4.4 아이피 맥 포워딩

HTTP 메시지는 주소가 붙은 데이터 패킷 형태로 보내지는데 각 패킷은 출발지와 목적지의 IP 주소와 TCP 포트번호로 구성된 레이어-4 주소를 가지고 있다. 각 패킷은 레이어-2 장비가 요구하는 MAC 주소도 가지고 있는데 레이어-2 장비는 주로 특정 맥 주소의 패킷을 받아서 다가는 특정 맥 주소로 포워딩 하는 역할을 한다.

레이어-4를 이해하는 스위치는 레이어-4 주소를 이용해 라우팅 할 수 있으며 예를들어 80 포트의 트래픽을 프락시 캐시로 보내고 다른 트래픽은 스위치로 전달 할 수 있다.  보통 요청을 여러 프락시 캐시로 보낼 수 있고 이들 사이의 부하 균형을 유지할 수 있다.

MAC 주소 포워딩은 점 대 점으로만 가능하여 서버나 프락시는 스위치와 한 홉 거리에 있어야 한다.

#### 20.4.5 아이피 주소 포워딩

스위치나 다른 레이어 4를 이해하는 장비는 들어오는 패킷에 대해 TCP/IP 어드레싱을 검증하고 패킷을 맥 주소가 아니라 목적지 아이피 주소의 변경에 따라 라우팅한다.

맥 포워딩과 다르게 목적지 서버가 한 홉 거리에 있을 필요가 없는데 스위치에서 업스트림의 위치를 판별 할 수 있다면 일반적인 레이어-3 종단간 인터넷 라우팅이 패킷을 올바른 위치로 보내준다. 이를 네트워크 주소 변환(NAT)라고 한다.

하지만 라우팅 대칭성 문제가 있는데 클라이언트로 들어오는 TCP 커넥션을 받는 스위치는 그 커넥션을 관리하고 있고 스위치는 반드시 그 커넥션을 통해 클라이언트에게 응답을 해야 하므로 목적지 서버나 프락시로부터의 모든 응답은 그 스위치에 돌아가야 한다.

응답의 귀환 경로를 제어하는 방법은 다음과 같다.

- 패킷의 출발지 아이피 주소를 스위치의 아이피 주소로 바꿔 스위치와 서버 사이의 네트워크 설정과 관계 없이 응답 패킷을 스위치로 가게 한다.
- 출발지 아이피 주소가 클라이언트의 아이피 주소로 계속 남아있다면 서버에서 클라이언트로 바로 가는 경로가 없어야 한다. 서버가 클라이언트 아이피 주소를 얻을 수 있으나 클라이언트와 서버 사이의 네트워크 전체에 약간의 통제가 필요하다.

[X-Forwarded-For](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/X-Forwarded-For)
#### 20.4.6 네트워크 구성요소 제어 프로토콜(NECP)

이는 아이디 패킷을 전달하는 라우터나 스위치 같은 네트워크 구성요소(NE)들이 웹 서버나 프락시 캐시와 같이 애플리케이션 계층 요청을 처리하는 서버 구성요소(SE)들과 대화 할 수 있게 한다. 부하 균형을 명시적으로 지원하지는 않지만 SE는 NE에게 부하 균형 정보를 제공할 수 있고 SE가 적합하다고 판단한 방법으로 NE가 부하 균형을 유지할 수 있게 한다.

NECP는 MAC 포워딩, GRE 캡슐화, NAT와 같이 패킷을 전달하는 여러 방법을 제공한다.

예외에 대한 개념을 지원하며 SE는 특정 출발지 아이피 주소가 서비스 할 수 없다고 판단하면 그 주소를 NE로 보낼 수 있다. 그러면 NE는 그 아이피 주소의 요청을 원 서버로 전달 할 수 있다.

### 20.5 프락시 리다이렉션 방법

콘텐츠에 접근하기 위해 프락시를 통해야 하는 경우도 있으며 클라이언트가 이용하기 위한 프락시 캐시가 네트워크에 있을 수도 있다.

웹브라우저 같은 클라이언트가 프락시로 가는 방법을 알기위해 명시적인 브라우저 설정, 동적인 자동설정, 자연스로운 가로채기를 할 수 있다.

#### 20.5.1 명시적 브라우저 설정

대부분의 브라우저에는 프락시 서버에 접촉하기 위해 프락시 이름, 아이피 주소, 포트번호를 설정 할 수 있는 메뉴가 있으며 사용자가 이를 설정하면 브라우저는 모든 요청에 대해 프락시와 접촉한다. 몇몇 서비스 제공자는 이미 프락시 설정이 되어 있는 브라우저를 제공하기도 한다.

다만 프락시를 사용하도록 설정된 브라우저는 프락시가 응답하지 않더라도 원 서버와 접촉하지 않으므로 프락시가 다운되거나 설정이 잘못 되면 사용자는 접속 문제를 겪는다. 그리고 네트워크 아키텍처를 변경 했을 때 변경 사항을 최종 사용자에게 전파하기 어렵다. 서비스 제공자가 더 많은 프락시를 추가하거나 몇 개를 서비스에서 제거하기 위해서는 브라우저 사용자들이 설정을 변경해야 한다.
#### 20.5.2 프락시 자동 설정

PAC는 넷스케이프 사에 의해 정의되었으며 거의 모든 브라우저가 지원한다. 브라우저들이 URL별로 접촉해야 할 프락시를 지정한 PAC 파일을 지정된 서버에 접촉하여 찾게 하고 재시작될 때 마다 PAC 파일을 가져온다.

PAC 프로토콜은 DNS 주소나 서브넷, 요일이나 시각과 같은 매개변수에 따라 프락시를 선택하도록 할 수 있으며 프락시의 위치가 변경된 경우 PAC를 서버에서 업데이트하여 브라우저에서 올바른 프락시에 연결하도록 할 수 있다.

PAC 파일의 예시([FindProxyForURL](https://findproxyforurl.com))
```js
function FindProxyForURL(url, host) { 
// If the hostname matches, send direct. 
    if (dnsDomainIs(host, "intranet.domain.com") || 
        shExpMatch(host, "(*.abcdomain.com|abcdomain.com)")) 
        return "DIRECT"; 

// If the protocol or URL matches, send direct. 
    if (url.substring(0, 4)=="ftp:" || 
        shExpMatch(url, "http://abcdomain.com/folder/*")) 
        return "DIRECT"; 

// If the requested website is hosted within the internal network, send direct. 
    if (isPlainHostName(host) || 
        shExpMatch(host, "*.local") || 
        isInNet(dnsResolve(host), "10.0.0.0", "255.0.0.0") || 
        isInNet(dnsResolve(host), "172.16.0.0", "255.240.0.0") || 
        isInNet(dnsResolve(host), "192.168.0.0", "255.255.0.0") || 
        isInNet(dnsResolve(host), "127.0.0.0", "255.255.255.0")) 
        return "DIRECT"; 

// If the IP address of the local machine is within a defined 
// subnet, send to a specific proxy. 
    if (isInNet(myIpAddress(), "10.10.5.0", "255.255.255.0")) 
        return "PROXY 1.2.3.4:8080"; 

// DEFAULT RULE: All other traffic, use below proxies, in fail-over order. 
    return "PROXY 4.5.6.7:8080; PROXY 7.8.9.10:8080"; }
```
#### 20.5.3 웹 프락시 자동발견 프로토콜

사용자가 수동으로 프락시를 설정하거나 트래픽 인터셉트에 의존하지 않고 웹브라우저가 근처의 프락시를 찾아서 사용할 수 있게 하는 것을 목적으로 하고 있는 프로토콜이다.

##### PAC 파일 자동발견
HTTP 클라이언트가 PAC 파일의 위치를 알아내고 그 파일을 이용해 적절한 프락시 서버의 이름을 찾을 수 있게 한다.

WPAD로 PAC 파일 CURL을 찾고 URL에 해당하는 PAC 파일을 가져온다. 이후 프락시 서버를 알아내기 위해 PAC 파일을 실행하여 반환된 프락시 서버에게 HTTP 요청을 보낸다.

##### WPAD 알고리즘
WPAD는 여러 리소스 발견 기법을 사용하며 WPAD 명세에서는 아래 기법을 순서대로 정의하고 있다.
- DHCP : 동적 호스트 설정 프로토콜
- SLP : 서비스 위치 프로토콜
- DNS에게 잘 알려진 호스트 명
- DNS의 SRV 레코드
- TXT 레코드의 DNS 서비스 URL들

WPAD 클라이언트에게는 DHCP와 DNS에게 잘 알려진 호스트 명 기법만이 요구된다.

클라이언트는 발견 메커니즘을 이용해 리소스 발견 요청을 순서대로 보내는데 클라이언트가 지원하는 메커니즘만을 시도하며 성공 할 때 마다 PAC CURL을 생성하기 위해 취득한 정보를 활용한다.

PAC 파일이 발견되었다면 과정은 완료되고 그렇지 않으면 리소스 발견 요청의 연쇄를 중단한 시점에서 다시 시작한다. 모든 메커니즘을 시도하고도 PAC를 찾지 못하면 프락시 서버를 사용하지 않는 것으로 설정된다.
##### DHCP를 이용한 CURL 발견
이 메커니즘의 동작을 위해 DHCP 서버는 반드시 CURL을 저장하고 있어야 하며 CURL은 DHCP 옵션코드 252에 들어있다. 이 옵션 코드는 임의의 길이의 문자열으로 PAC 파일을 가리키는 URL을 포함한다.

##### DNS A 레코드 룩업
프락시 서버의 IP 주소들이 DNS 서버에 저장되어 있어야 하고 클라이언트는 A 레코드 룩업을 DNS 서버로 보내 CURL을 얻는다.

클라이언트가 아래와 같이 DNS 룩업을 수행하고 룩업에 성공하면 해당되는 URL의 IP 주소를 얻는다.

```
QNAME=wpad.TGTDOM., QCLASS=IN, QTYPE=A
```

##### PAC 파일 가져오기
후보 CURL이 생성되면 클라이언트는 보통 CURL로 GET 요청을 보내고 자신이 다룰 수 있는 CFILE 포멧 정보를 Accept 헤더를 포함해야 한다.

```
Accept: application/x-ns-proxy-autoconfig
```

CURL 결과가 리다이렉트라면 리다이렉트 위치가 클라이언트의 최종 목적지이다.

##### 언제 WPAD를 실행하는가
WPAD는 웹 클라이언트가 시작될 때, 또는 클라이언트 호스트의 아이피 주소가 변경된 네트워킹 스택으로부터 어떤 언급이 있을 때 마다 실행해야 한다.

클라이언트는 이전에 다운 받은 PAC 파일이 HTTP 만료 규칙에 따라 만료되었을 때 반드시 발견 사이클을 다시 시도해야 한다.

클라이언트는 PAC 파일이 대체품을 제공하지 않을 경우 현재 설정된 프락시가 동작하지 않을 때 WPAD 프로세스를 재실행하도록 구현할 수도 있으며 클라이언트가 PAC 파일을 무효화하기로 했다면 이 프로토콜이 `If-Modified-Since` 요청을 지원하지 않으므로 전체 WPAD 프로토콜을 재 실행해야 한다.

##### WPAD 스푸핑
WPAD의 알고리즘은 호스트명 'wpad'를 도메인 이름 앞에 붙이고 WPAD 서버를 찾아내거나 3차 도메인에 도달 할 때까지 서브도메인을 지운다. 예를 들어 도메인이 a.b.acme.com이라면 웹 클라이언트는 wpad.a.b.acme.com, wpad.b.acme.com, wpad.acme.com를 질의한다.

이 경우 미국 밖에서 3차 도메인은 신뢰하기 어려우므로 악의적인 사용자가 WPAD 서버 설정을 하고 그의 의도대로 프락시가 설정되도록 할 수 있으므로 현재는 문제를 개선했다.

##### 타임아웃
클라이언트는 WPAD의 각 단계가 일정한 시간 내에 끝나는지 반드시 확인해야 하며 네트워크 특성을 고려하여 설정해야 한다.

##### 관리자를 위한 고려사항
클라이언트들이 하위 호환을 위해 반드시 구현해야 하는 것은 DHCP와 DNS A 레코드 검색뿐으로 관리자들은 이 둘 중 하나를 설정해야 하고 검색 순서에서 이 메커니즘을 먼저 지원하도록 설정하면 클라이언트가 시작하는데 걸리는 시간을 줄일 수 있다.

프로토콜 구조를 갖게 된 이유 중 하나는 클라이언트가 근처에 있는 프락시 서버를 찾기 위함이고 다양한 환경에서 여러가지 프락시 서버들이 사용된다.

WPAD 프레임워크에서 근접성을 결정할 때 다음 가능성들을 고려할 수 있다.

- DHCP 서버들은 서브넷에 따라 다른 답을 돌려 줄 수 있고 클라이언트의 cipaddr 필드나 식별자 옵션을 따른다.
- DNS 서버는 도메인 접미사에 따라 다른 SRV/A/TXT 리소스 레코드를 반환하도록 설정 될 수 있다.
- CURL 요청을 다루는 웹 서버는 User-Agent 헤더, Accept 헤더, 클라이언트 아이피 주소/서브넷/호스트 명, 인근 프락시 서버들의 위상기하학정 배치 등에 근거하여 결정 할 수 있으며 CURL을 다루기 위해 생성된 CGI나 프락시 서버에서 결정을 내릴 수도 있다.
- PAC 파일은 여러 대안 중 하나를 실시간으로 선택할 수 있을만한 충분한 표현력이 있을 수 있다. CARP는 이를 바탕으로 캐시의 배열을 지원한다.

### 20.6 캐시 리다이렉션 방법

캐싱 프락시 서버를 위해 사용되는 복잡한 리다이렉션 기법으로 신뢰성 높고, 고성능에 콘텐츠 지각 디스패칭까지 가능하게 한다.

#### 20.6.1 WCCP 리다이렉션

시스코 시스템즈는 웹 라우터들이 웹 트래픽을 프락시 캐시로 리다이렉트 할 수 있도록 WCCP를 개발했으며 WCCP는 라우터들과 캐시들 사이의 대화를 관리하여 라우터가 캐시를 검사하고 특정 종류의 트래픽을 특정 캐시로 보낼 수 있게 해 준다.

##### WCCP 리다이렉션 동작
네트워크가 필요하며 네트워크에는 WCCP를 사용 할 수 있는 라우터와 다른 캐시와 의사소통 할 수 있는 캐시가 포함되어야 한다.

라우터들의 집합과 대상이 되는 캐시들이 WCCP 서비스 그룹을 구성하여 어떤 트래픽이 어디로 어떻게 보내지는지, 서비스 그룹에서 부하가 캐시들 사이에서 어떻게 분산되어야 하는지 명시한다.

서비스 그룹이 HTTP 트래픽을 리다이렉션하도록 설정되어 있다면 서비스 그룹의 라우터는 HTTP 요청을 서비스 그룹의 캐시로 보내고 서비스 그룹의 라우터에 요청이 도착하면 라우터는 요청을 처리하기 위해 서비스 그룹의 캐시 중 하나를 선택한다.

라우터는 요청 패킷을 캐시의 아이피 주소와 함께 캡슐화하거나 아이피 맥 포워딩하여 캐시로 보내고 캐시가 요청을 처리할 수 없다면 패킷은 다시 라우터로 돌아온다.

서비스 그룹은 다른 구성원들의 가용성을 확인하기 위해 하트비트 메시지를 교환한다.

##### WCCP 메시지들
![WCCP2 메시지](attachments/Pasted%20image%2020231202093410.png)

##### 메시지 구성요소
WCCP 메시지는 헤더와 구성요소로 구성되어 있으며 메시지의 종류, WCCP 버전, 메시지의 길이를 포함한다. 각 구성요소는 구성요소의 종류와 길이를 서술하는 4바이트 헤더로 시작하며 구성요소 길이는 헤더의 길이를 포함하지 않는다.

##### 서비스 그룹
서비스 그룹은 WCCP 메시지를 교환 할 수 있는 라우터와 캐시들로 구성되어 있으며 라우터들은 웹 트래픽을 서비스 그룹의 캐시로 보낸다. 서비스 그룹의 설정은 트래픽이 어떻게 서비스 그룹의 캐시들로 분산될지 결정하며 라우터와 캐시는 Here I Am과 I See You 메시지를 이용해 서비스 그룹 설정 정보를 교환한다.

##### GRE 패킷 캡슐화
WCCP를 지원하는 라우터들은 HTTP 패킷을 서버의 IP 주소화 함께 캡슐화하여 그 서버로 리다이렉트하며 캡슐화된 패킷에는 IP 헤더 proto 필드도 포함하고 있다.

proto 필드는 수신측 프락시에게 패킷이 캡슐화된 패킷을 갖고 있음을 알려주고 패킷이 캡슐화되어 있으므로 클라이언트 아이피 주소를 잃어버리지 않는다.

##### WCCP 부하 균형
WCCP 라우터는 라우팅뿐만 아니라 서버 간의 부하 균형을 유지할 수 있는데 각 수신 서버들은 서로의 상태를 알 수 있도록 하트비트 메시지를 서로 교환하며 특정 수신 서버가 하트비트 메시지를 보내지 않게 되면 WCCP 라우터는 트래픽을 그 노드로 리다이렉트 하지 않고 인터넷으로 바로 보낸다. 하트비트를 다시 수신하면 그 노드로 요청 트래픽을 보내기 시작한다.

### 20.7 인터넷 캐시 프로토콜(ICP)

캐시들이 형제 캐시에서 일어난 캐시 적중을 찾아볼 수 있게 해 주는 프로토콜으로 캐시가 HTTP 메시지에서 요청한 콘턴츠를 갖고 있지 않다면 근처의 형제 캐시 중 그 콘텐츠를 갖고 있는 것이 있는지 찾아보고 만약 있다면 그 캐시에서 콘텐츠를 가져온다.

ICP는 일종의 캐시 클러스터링 프로토콜으로 한 차례 이상의 ICP 질의를 통해 HTTP 요청 메시지의 최종 목적지를 결정할 수 있으므로 이 프로토콜은 리다이렉션 프로토콜이다.

캐시는 이 프로토콜을 사용해 근처의 캐시 모드에게 특정 URL을 갖고 있는지 한번에 물어보고 근처에 캐시들은 그 URL을 가지고 있다면 `HIT`, 아니면 `MISS`라고 답한다. 그러면 물어본 캐시는 객체를 갖고 있는 이웃 캐시에 대한 HTTP 커넥션을 열 수 있다.

ICP 메시지는 파싱하기 쉽도록 네트워크 바이트 순서에 따라 32비트 크리고 맞춰져 있으며 이 메시지들은 UDP로 전송된다. UDP는 전송 중 손실 될 수 있으므로 데이터그램의 손실을 감지할 수 있도록 타임아웃이 설정되어야 한다.

ICP 메시지는 OP 코드, 버전, 메시지 길이, 요청 번호, 옵션, 옵션 데이터, 발송자 호스트 주소, 페이로드로 구성된다.

### 20.8 캐시 배열 라우팅 프로토콜

프락시 서버는 사용자 개개인으로부터 요청을 가로채서 요청한 객체의 캐시된 사본을 제공하여 트래픽을 줄여주지만 사용자의 증가에 따라 대량의 트래픽은 프락시 서버 자체에 과도한 부하를 줄 수 있다.

이를 해결하기 위해 프락시 서버를 여러 대로 늘릴 수 있는데 캐시 배열 라우팅 프로토콜(CARP)은 프락시 서버의 배열이 클라이언트의 시점에서 하나의 논리적인 캐시처럼 보이도록 관리해주는 표준이다.

CARP는 ICP의 대안으로 모두 관리자가 여러 대의 프락시 서버를 사용해 성능을 개선할 수 있게 해준다.

ICP 프로토콜로 서로 연결된 프락시 서버들 각각은 콘텐츠의 불필요한 복제본을 가지고 있는 톡립적인 캐시이고 CARP로 동작하는 서버들은 각 구성요소 서버가 전체 캐시된 문서의 일부만 가지고 있는 하나의 큰 서버처럼 동작하며 하나의 웹 객체는 하나의 프락시 서버에만 있으므로 서버 각각을 폴링하지 않고 한 번의 검색으로 그 위치를 결정 할 수 있다.

하지만 CARP는 프락시 서버 중 하나가 사용할 수 없게 되면 이를 반영하기 위해 해시 함수가 수정되야 하고 프락시 서버 전체에 퍼져있는 콘텐츠를 다시 배치해야 하는 단점이 있다.
### 20.9 하이퍼텍스트 캐싱 프로토콜(HTCP)

이 프로토콜은 형제들이 URL과 모든 요청 및 응답 헤더를 사용하여 서로에게 문서의 존재 여부에 대한 질의를 할 수 있도록하여 적중이 아닌데 적중으로 잘못 처리될 확률을 줄인다. 그리고 형제 캐시들이 서로의 캐시 안에 있는 선택된 문서의 추가 및 삭제를 모니터링 하고 요청 할 수 있고 서로 캐시된 문서에 대한 캐싱 정책을 변경할 수 있게 해준다.

HTCP 메시지 구조는 아래와 같으며 헤더 부분은 메시지의 길이와 메시지의 버전을 포함한다, 데이터 부분은 OP 코드를 포함한 데이터의 길이로 시작하여 응답코드, 몇몇 태그들과 아이디들을 포함하여 실제 데이터로 끝난다.

![HTCP 메시지 포멧](attachments/Pasted%20image%2020231202095302.png)

#### 20.9.1 HTCP 인증

인증 부분은 선택적이며 구성 요소는 아래와 같다.

![HTCP 인증 구성요소](attachments/Pasted%20image%2020231202095528.png)
#### 20.9.2 캐싱 정책 설정
SET 메시지는 캐시가 캐시된 문서에 대한 정책 변경을 요청할 수 있게 해주며 SET 메시지에서 사용할 수 있는 헤더는 아래와 같다.

![캐싱 정책 변경을 위한 캐시 헤더들의 목록](attachments/Pasted%20image%2020231202095602.png)

요청과 응답 헤더를 질의 메시지에 담아 형제 캐시로 보낼 수 있으므로 HTCP는 캐시 질의에서 거짓 적중의 비율을 줄일 수 있고 정책 정보를 서로 교환하여 서로를 도울 수 있게 해 준다.