사용자를 식별하고 인증하는 HTTP의 기능들은 적대행위에서 중요한 트랜젝션을 보호하기에 부족하므로 디지털 암호화를 이용해 도청이나 위조로부터 트랜젝션을 보호하기 위한 기술을 제시한다.

## 14.1 HTTP를 안전하게 만들기

강력한 보안을 통해 웹 트랜젝션을 중요한 일에 사용하기 위해 HTTP와 디지털 암호화 기술을 결합해야 한다.

- **서버 인증** 클라이언트는 자신이 진짜 서버와 연결되었음을 알 수 있어야 한다.
- **클라이언트 인증** 서버는 자신이 진짜 사용자와 이야기 할 수 있음을 알 수 있어야 한다.
- **무결성** 클라이언트와 서버간 데이터는 위조로부터 안전해야 한다.
- **암호화** 클라이언트와 서버는 도청에 대한 걱정 없이 데이터를 주고받아야 한다.
- **효율** 낮은 사양의 클라이언트나 서버도 이용할 수 있도록 알고리즘이 가벼워야 한다.
- **편재성(Ubiquity)** 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- **관리상 확장성** 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- **적응성** 현재 알려진 최선의 보안 방법을 지원해야 한다.
- **사회적 생존성** 사회의 문화적, 정치적 요구를 만족시켜야 한다.

### 14.1.1 HTTPS

HTTPS는 가장 인기있는 보안 방식으로 넷스케이프에서 개발하고 모든 주류 브라우저와 서버에서 지원한다.

HTTPS를 사용 할 때 모든 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다. HTTP의 하부에 전송 레벨 암호 보안 계층을 제공하여 동작하는데 Secure Sockets Layer(SSL)이나 Transport Layer Security(TSL)를 이용해 구현되며 두 방식은 매우 비슷하므로 두 방식 모두를 SSL로 지칭하기도 한다.

### 14.2 디지털 암호학

- **암호** 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- **키** 암호의 동작을 변경하는 숫자로 된 매개변수
- **대칭키 암호 체계** 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- **비대칭키 암호 체계** 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- **공개키 암호법** 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- **디지털 서명** 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- **디지털 인증서** 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 14.2.1 비밀 코드의 기술과 과학

암호법은 메시지 암호화 뿐만 아니라 메시지의 변조를 방지하기 이해 사용할 수 있다. 수표의 서명이나 봉투의 왁스 봉인과 같이 누군가 어떤 메시지나 트랜젝션의 저자임을 증명하는데 사용될 수 있다.

### 14.2.2 암호(cipher)

암호란 메시지를 인코딩하는 방법과 그 암호화된 메시지를 디코딩하는 방법이다. 인코딩 되기 전의 원본 메시지는 텍스트 또는 평문이라고 불리고 암호가 적용된 메시지는 암호문이라고 불린다.

율리우스 카이사르는 메시지의 각 글자를 해당 글자의 알파벳 순서상 세 번 뒤의 글자로 교체하는 세글자 순환 암호를 사용했다.

### 14.2.3 암호 기계

간단한 알고리즘의 암호화는 사람이 직접 할 수 있었지만 반대로 간단하게 암호를 깨트릴 수도 있었다. 기술의 진보에 따라 복잡한 인코딩을 이용해 암호를 깨트리기 어렵게 하였고 글자들을 대체하고 순서를 바꾸고 메시지를 자르고 토막냈다.

가장 유명한 기계식 암호 기계는 2차 세계대전 당시 독일군이 사용한 에니그마 암호 기계이다.
### 14.2.4 키가 있는 암호

대부분의 암호화 기계들은 암호의 동작 방식을 변경 할 수 있었다. 이러한 암호 매개 변수를 키라고 부르고 디코딩 과정을 위해 올바른 키를 기계에 입력해야 한다. 암호 키에 따라 제각각 다르게 동작 할 수 있다.

애니그마 암호 기계는 매일 반복되는 인사말을 토대로 암호 키를 알아내 암호를 깨트릴 수 있었다.

### 14.2.5 디지털 암호

디지털 계산의 발전으로 기계 장치의 한계에서 벗어나 복잡한 인코딩과 디코딩 알고리즘이 가능해졌고 매우 큰 키를 사용 할 수 있어 단일 암호 알고리즘으로 수조개의 가상 암호 알고리즘을 만들 수 있게 되었다. 키가 길수록 인코딩의 많은 조합이 가능해지고 무작위 대입에 의한 크랙이 어려워진다.

## 14.3 대칭키 암호법

인코딩과 디코딩에 같은 키를 사용하는 알고리즘으로 대표적으로 DES, Triple-DES, RC2, RC4 등이 있다.

### 14.3.1 키 길이와 열거 공격(Enumeration Attack)

대부분 암호화 알고리즘은 공개 되어 있으므로 비밀 키가 누설되면 안된다. 무차별로 모든 키 값을 대입해 보는 공격을 열거공격이라고 하며 가능한 키 값이 몇가지 밖에 없다면 암호가 쉽게 깨질 수 있다.

가능한 키 값의 개수는 키의 비트값에 따라 가능한 값의 수가 달라지며 8비트라면 256가지, 40비트라면 1조가지가 가능하다. 40비트 키는 작고 중요하지 않은 업무에는 충분하지만 1995년 기준 19만 달러를 들이면 2초 내에 암호를 깨트릴 수 있다.

반면 128비트 키는 10<sup>15</sup>년이 걸리므로 무차별 대입으로는 실질적으로 깨트리기 어렵다고 알려져있다.

### 14.3.2 공유키 발급하기

대칭키 암호의 단점으로 발송자와 수신자가 대화를 위해 모두 공유키를 가져야 한다. 웹 페이지에 접속하는 사용자마다 키를 발급하기 위해서는 수 많은 키를 생성하고 관리해야 한다. 만약 N개의 노드(사용자)가 있고 각 노드가 상대와 암호로 대화를 나누기 위해 N<sup>2</sup>개의 비밀 키가 필요하다.

## 14.4 공개키 암호법

두 개의 비대칭 키를 사용하는 방식으로 하나는 호스트의 메시지를 인코딩 하기 위해 사용되고 다른 하나는 암호화된 메시지를 디코딩하기 위해 사용된다.

인코딩 키는 공개 되어 있어 누구나 암호화된 메시지를 보낼 수 있지만 암호화된 메시지는 디코딩 하기 위한 키의 소유자만 해석 할 수 있어 메시지를 중간에 탈취한다고 하더라도 비밀이 유출되지 않는다.

이러한 공개키 암호화 기술으로 모든 컴퓨터 사용자에게 보안 프로토콜을 적용하는 것이 가능해졌다.

### 14.4.1 RSA

MIT에서 발명되고 RSA 데이터 시큐리티에서 상용화된 알고리즘으로 공개키, 평문의 일부, 공개키로 평문을 인코딩하여 얻은 평문에 대한 암호문, RSA 구현의 소스코드까지 주여지더라도 암호를 크래킹하여 개인키를 얻어내는것이 거의 불가능한 방식이다.

### 14.4.2 혼성 암호 체계와 세션 키

공개키 암호 방식의 알고리즘은 계산이 오래 걸리므로 실제로는 대칭과 비대칭 방식을 함께 사용한다.

노드들 사이의 안전한 의사소통 채널을 만들 때는 공개 키 암호를 사용하고 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여 나머지 데이터를 암호화 할 때는 빠른 대칭 키를 사용한다.

## 14.5 디지털 서명

메시지의 작성자와 위조 여부를 확인 하기 위해 디지털 서명이 필요하며 이 기법에 암호 체계를 활용 할 수 있다.

### 14.5.1 서명은 암호 체크섬이다

디지털 서명은 메시지를 고정된 길이의 요약으로 만들고 개인 키를 매개 변수로 서명을 인코딩(디코딩 함수를 적용) 한다. 메시지를 받은 노드에서 위조 여부를 확인하기 위해 서명을 디코딩 하고 디코딩 된 서명과 평문 메시지의 요약이 일치하는지 확인할 수 있다.

## 14.6 디지털 인증서

디지털 인증서는 신뢰할 수 있는 기관에서 보증받은 사용자나 회사에 대한 정보를 담고 있다.

### 14.6.1 인증서의 내부

인증서에는 대상의 공개키도 담고 있어 누구나 디지털 인증서를 만들 수는 있지만 서명은 할 수 없다.

![github.com의 인증서 정보](attachments/Pasted%20image%2020231102070614.png)
### 14.6.2 X.509 v3 인증서

디지털 인증서에 대한 공통 표준은 없지만 대부분의 인증서가 X.509라는 표준화된 서식에 정보를 저장하고 있다.

필드 | 설명
--- | ---
버전 | 인증서 버전 번호
서명 알고리즘| 서명을 위해 사용된 암호 알고리즘
인증서 발급자| 인증서를 발급하고 서명한 기관의 이름
유효 기간 | 인증서가 유효한 기간
대상의 이름 | 사람이나 조직
대상의 공개 키 정보 | 공개키와 알고리즘, 추가 매개변수

### 14.6.3 서버 인증을 위해 인증서 사용하기

사용자가 HTTPS를 통해 웹 트랜젝션을 시작 할 때 브라우저는 접속한 서버에서 디지털 인증서를 가져오고 서버에 인증서가 없다면 보안 연결은 실패한다.

브라우저가 인증서를 받으면 서명 기관을 검사하고 신뢰 할 만한 서명 기관이라면 브라우저 내부에 이미 설치된 기관의 공개키를 이용해 서명을 검증한다.

서명 기관이 모르는 곳이라면 사용자가 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 보여준다.

## 14.7 HTTPS의 세부사항

HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법을 결합한 보안 버전으로 상용 브라우저와 서버에 구현되어 있다.

### 14.7.1 HTTPS 개요

HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 보안 계층으로 보낸다. 보안 계층은 SSL과 TCL으로 구현되었다.

### 14.7.2 HTTPS 스킴

HTTPS의 URL 접두사는 https이며 SSL 트래픽은 바이너리 프로토콜이므로 같은 포트로 연결된다면 브라우저는 SSL 트래픽을 잘못된 HTTP로 해석할 수 있어 서로 다른 포트(80, 443)을 사용한다.

### 14.7.3 보안 전송 셋업

HTTPS에서 클라이언트는 웹 서버의 443 포트로 연결한다. TCP 연결이 되고 나면 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화 한다.

핸드셰이크가 완료되면 SSL 초기화가 완료되어 클라이언트가 요청 메시지를 보안 계층에 보낼 수 있다.

![HTTP와 HTTPS 트랜잭션](attachments/Pasted%20image%2020231102070709.png)
### 14.7.4 SSL 핸드셰이크

암호화된 HTTP 메시지를 보내기 위해 클라이언트와 서버는 SSL 핸드셰이크를 진행하며 클라이언트가 암호 후보들을 보내고 인증서를 요구하면 서버는 선택된 암호와 인증서를 보낸다. 이후 클라이언트가 비밀 정보를 보내면 클라이언트와 서버는 키를 만들고 서로 암호화를 시작한다고 알려준다.

### 14.7.5 서버 인증서

SSL은 서버와 클라이언트간 상호 인증을 지원하지만 대부분 사용자는 인증서를 가지고 있지 않으며 클라이언트 인증 또한 거의 진행되지 않는다.

보안 HTTPS 트랜젝션은 항상 서버인증서를 요구하며 알려진 인증기관에 의해 서명된 서버 인증서는 개인 정보를 보내기 전에 서버를 얼마나 신뢰 할 수 있는지 판단할 수 있게 한다.

서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름 등을 보여주는 X.509 V3에서 패상된 인증서로 사용자는 인증서를 검증 할 수 있다.

### 14.7.6 사이트 인증서 검사

SSL은 사용자에게 웹 서버 인증서 검증을 요구하지 않지만 대부분의 웹 브라우저들은 인증서에 대해 간단한 검사 후 그 결과를 사용자에게 알려준다. 넷스케이프가 제안한 웹 서버 인증서 검사 알고리즘은 아래와 같다.

**날짜 검사**
인증서의 인증서의 시작 및 종료일을 검사하고 인증서가 만료되거나 활성화 되지 않았다면 에러를 보여준다.

**서명자 신뢰도 검사**
모든 인증서는 서버를 보증하는 인증 기관에 의해 서명되어 있다. 누구나 인증서를 생성 할 수 있지만 브라우저에 포함되지 않은 인증기관으로 부터 서명 받은 경우 브라우저는 에러를 보여준다.

**서명 검사**
서명 기관이 믿을만 하다고 판단되면 서명기관의 공개키를 서명에 적용하여 체크섬과 비교하여 인증서의 무결성을 검사한다.

**사이트 신원 검사**
인증서의 도메인 이름이 대화 중인 서버의 도메인 이름과 동일한지 검사한다. 호스터 명이 인증서와 맞지 않으면 클라이언트는 사용자에게 알리거나 인증서 에러와 함께 연결을 끊어야 한다.
### 14.7.7 가상 호스팅과 인증서

웹 서버 프로그램이 하나의 인증서만 지원하는 경우가 있어 가상호스트로 운영되는 사이트의 경우 경고가 출력될 수 있다. 호스트 주소가 다른 경우 모든 사용자를 인증서에 나열된 호스트명의 URL으로 리다이렉트 하여 문제를 회피 할 수 있다.

## 14.8 진짜 HTTPS 클라이언트

SSL은 복잡한 바이너리 프로토콜으로 가공되지 않은 SSL 트래픽을 직접 보내기보다 라이브러리를 활용하자.

### 14.8.1 OpenSSL

SSL과 TLS 프로토콜을 구현한 오픈 소스 툴킷이다.

### 14.8.2 간단한 HTTPS 클라이언트

SSL 라이브러리를 초기화 한 후 서버의 호스트명을 IP 주소로 변환한다. 호스트의 443 포트로 TCP 커넥션을 열고 SSL 핸드셰이크를 개시한다. 핸드셰이크에서 선택된 암호를 출력하고 서버 인증서를 검사한다. 이후 SSL 스택에서 HTTP 응답을 읽은 뒤 커넥션을 종료한다.

HTTP 명령을 쓰고 읽기만 하면 SSL 계층에서 인코딩 / 디코딩을 모두 수행한다.

### 14.8.3 단순한 OpenSSL 클라이언트 실행하기

pass

## 14.9 프락시를 통한 보안 트래픽 터널링

클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화해서 보내면 프락시는 HTTP 헤더를 읽을 수 없다. 

HTTPS가 프락시와 잘 동작하기 위해 클라이언트가 HTTPS SSL 터널링 프로토콜을 사용해서 프락시에게 연결하고자 하는 호스트와 포트를 CONNECT 메서드와 함께 평문으로 알려준다.

프락시는 클라이언트와 서버 사이에 터널을 만들고 핸드셰이크 및 SSL 데이터 전송을 시작한다. 프락시는 클라이언트의 요청을 평가하여 요청이 유효하다면 서버로 연결하여 connection established 응답을 클라이언트에게 보낸다.

